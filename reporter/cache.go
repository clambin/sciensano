package reporter

import (
	"github.com/clambin/simplejson/v3/dataset"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	log "github.com/sirupsen/logrus"
	"sync"
	"time"
)

// Cache caches the different reports generated by the reporter package
type Cache struct {
	Duration time.Duration
	lock     sync.RWMutex
	entries  map[string]*CacheEntry
}

// CacheEntry represents one report in the cache
type CacheEntry struct {
	Once   sync.Once
	Data   *dataset.Dataset
	expiry time.Time
}

// NewCache returns a new cache that caches the reports for the specified duration
func NewCache(duration time.Duration) *Cache {
	return &Cache{
		Duration: duration,
		entries:  make(map[string]*CacheEntry),
	}
}

// Prometheus metrics
var (
	metricCacheMiss = promauto.NewCounterVec(prometheus.CounterOpts{
		Name: "sciensano_reports_cache_miss_total",
		Help: "Number of Reporter reports not served from cache",
	}, []string{"endpoint"})
	metricCacheCall = promauto.NewCounterVec(prometheus.CounterOpts{
		Name: "sciensano_reports_cache_total",
		Help: "Number of Reporter reports attempted to be served cache",
	}, []string{"endpoint"})
)

// Load returns a cached report. If the report does not exist, or is expired, it sets up Once to generate a new report
func (cache *Cache) Load(name string) (entry *CacheEntry) {
	cache.lock.Lock()
	defer cache.lock.Unlock()

	var ok bool
	if entry, ok = cache.entries[name]; ok == false {
		entry = &CacheEntry{}
	}
	if ok == false || time.Now().After(entry.expiry) {
		entry.Once = sync.Once{}
		entry.expiry = time.Now().Add(cache.Duration)
		// register it so only one call to Load will set up a new Once
		cache.entries[name] = entry
		metricCacheMiss.WithLabelValues(name).Add(1.0)
	}
	metricCacheCall.WithLabelValues(name).Add(1.0)
	return
}

// Save stores a generated report in the cache
func (cache *Cache) Save(name string, entry *CacheEntry) {
	cache.lock.Lock()
	defer cache.lock.Unlock()

	entry.expiry = time.Now().Add(cache.Duration)
	cache.entries[name] = entry
}

// Clear removes the specified report from the cache
func (cache *Cache) Clear(name string) {
	cache.lock.Lock()
	defer cache.lock.Unlock()

	delete(cache.entries, name)
}

// MaybeGenerate loads a report from Cache, or generates it if the report does not exist or is expired
func (cache *Cache) MaybeGenerate(name string, generate func() (*dataset.Dataset, error)) (report *dataset.Dataset, err error) {
	start := time.Now()
	defer func() { log.WithField("time", time.Since(start)).Debug(name + " done") }()

	log.Debug("running " + name)
	entry := cache.Load(name)
	entry.Once.Do(func() {
		entry.Data, err = generate()
		if err == nil {
			cache.Save(name, entry)
		} else {
			cache.Clear(name)
		}
	})
	if err == nil {
		report = entry.Data.Copy()
	}
	return
}

// Stats returns the stats of the cache
func (cache *Cache) Stats() (stats map[string]int) {
	cache.lock.RLock()
	defer cache.lock.RUnlock()

	stats = make(map[string]int)
	for name, entries := range cache.entries {
		count := 0
		if entries.Data != nil && !time.Now().After(entries.expiry) {
			count = entries.Data.Size()
		}
		stats[name] = count
	}
	return
}
