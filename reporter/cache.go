package reporter

import (
	"github.com/clambin/cache"
	"github.com/clambin/simplejson/v3/dataset"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"sync"
	"time"
)

// Cache caches the different reports generated by the reporter package
type Cache struct {
	cache.Cacher[string, *CacheEntry]
	lock sync.RWMutex
}

// CacheEntry represents one report in the cache
type CacheEntry struct {
	Once sync.Once
	Data *dataset.Dataset
}

// NewCache returns a new cache that caches the reports for the specified duration
func NewCache(duration time.Duration) *Cache {
	return &Cache{
		Cacher: cache.New[string, *CacheEntry](duration, 5*time.Minute),
	}
}

// Prometheus metrics
var (
	metricCacheMiss = promauto.NewCounterVec(prometheus.CounterOpts{
		Name: "sciensano_reports_cache_miss_total",
		Help: "Number of Reporter reports not served from cache",
	}, []string{"endpoint"})
	metricCacheCall = promauto.NewCounterVec(prometheus.CounterOpts{
		Name: "sciensano_reports_cache_total",
		Help: "Number of Reporter reports attempted to be served cache",
	}, []string{"endpoint"})
)

// Load returns a cached report. If the report does not exist, or is expired, it sets up Once to generate a new report
func (cache *Cache) Load(name string) (entry *CacheEntry) {
	cache.lock.Lock()
	defer cache.lock.Unlock()

	var ok bool
	if entry, ok = cache.Cacher.Get(name); !ok {
		entry = &CacheEntry{}
	}
	if !ok || entry == nil {
		entry = &CacheEntry{
			Once: sync.Once{},
		}
		// register it so only one call to Load will set up a new Once
		cache.Cacher.Add(name, entry)
		metricCacheMiss.WithLabelValues(name).Add(1.0)
	}
	metricCacheCall.WithLabelValues(name).Add(1.0)
	return
}

// Save stores a generated report in the cache
func (cache *Cache) Save(name string, entry *CacheEntry) {
	cache.Cacher.Add(name, entry)
}

// MaybeGenerate loads a report from Cache, or generates it if the report does not exist or is expired
func (cache *Cache) MaybeGenerate(name string, generate func() (*dataset.Dataset, error)) (report *dataset.Dataset, err error) {
	// start := time.Now()
	// defer func() { log.WithField("time", time.Since(start)).Debug(name + " done") }()

	// log.Debug("running " + name)
	entry := cache.Load(name)
	entry.Once.Do(func() {
		entry.Data, err = generate()
		if err != nil {
			entry = nil
		}
		cache.Save(name, entry)
	})
	if err == nil {
		report = entry.Data.Copy()
	}
	return
}

// Stats returns the stats of the cache
func (cache *Cache) Stats() (stats map[string]int) {
	cache.lock.RLock()
	defer cache.lock.RUnlock()

	stats = make(map[string]int)
	for _, name := range cache.GetKeys() {
		entries, ok := cache.Get(name)
		var count int
		if ok {
			count = entries.Data.Size()
		}
		stats[name] = count
	}
	return
}
